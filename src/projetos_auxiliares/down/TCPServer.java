/** @TCPServer: Servidor para conexao TCP com Threads *                Fornece o Socket e conexão entre clientes e processa as mensagens * * Universidade Tecnológica Federal do Paraná - UTFPR-CM * @Autor: Gabriel Negrão Silva * @Data: 29/09/2017 */package Parte4;import java.net.*;import java.io.*;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.logging.Level;import java.util.logging.Logger;import java.io.DataInputStream;public class TCPServer {       public static ArrayList<TaskThread> Clientes;       public static void main (String args[]) {       startServer();    } //main        public static void startServer(){    (new Thread() {        @Override        public void run() {            try{                Clientes = new ArrayList<TaskThread>();                int serverPort = 7896; // porta do servidor                /* cria um socket e mapeia a porta para aguardar conexao */                ServerSocket listenSocket = new ServerSocket(serverPort);                while(true) {                    System.out.println ("Servidor aguardando conexao ...");                    /* aguarda conexoes */                    Socket clientSocket = listenSocket.accept();                    System.out.println ("Cliente conectado ... Criando thread ...");                    /* cria um thread para atender a conexao */                    TaskThread c = new TaskThread(clientSocket);                    Clientes.add(c);                } //while            } catch(IOException e) {                System.out.println("Listen socket:"+e.getMessage());            } //catch                }        }    ).start();//Thread   }//metodo       public static void removeClient(TaskThread cli){       Clientes.remove(cli);          }} //class/** * Classe TaskThread: Thread responsavel pela comunicacao * Descricao: Rebebe um socket, cria os objetos de leitura e escrita e aguarda msgs clientes  */class TaskThread extends Thread {    private static DataInputStream in;    private static DataOutputStream out;    private static FileInputStream outToClient;    private static Socket clientSocket;    private static Thread servidorEnviaFILE;        //Definir pasta padrão dos arquivos    public static String pastaPredef = "/home/itsgnegrao/Documentos/Shared/";         public TaskThread (Socket aClientSocket) {        try {            clientSocket = aClientSocket;            in = new DataInputStream( clientSocket.getInputStream());            out =new DataOutputStream( clientSocket.getOutputStream());            this.start();  /* inicializa a thread */        } catch(IOException e) {	    System.out.println("Connection:"+e.getMessage());	} //catch    } //construtor        /* metodo executado ao iniciar a thread - start() */    public void run(){        try {        int i;        File f = null;        File[] list;        String data = "";		while(true){			                 	                     data = in.readUTF();   /* aguarda o recebimento de dados */                     String parse = data.replaceAll("\\[.*\\]\\: ", ""); //retira apelido        	    System.out.println (data);                                                             /*TIME Retorna a hora do sistema como uma String UTF no formato HH:MM:SS + PM/AM*/                    if(parse.equals("TIME")){                        Date dateToFormat = new Date();                        SimpleDateFormat dateFormatExpression = new SimpleDateFormat("hh:mm:ss a"+"\n");                        String formattedDate = dateFormatExpression.format(dateToFormat);                        out.writeUTF(formattedDate);                        out.flush();                    }                                        /*Retorna o nome e tamanho dos arquivos da pasta pré definida*/                    else if(parse.equals("FILES")){                        f = new File(pastaPredef);                        list = f.listFiles();                                                                   // aviso de retorno de qtde de arquivos na pasta                        out.writeUTF("QTD-PATH");                        out.flush();                                                //retorno de qtde na pasta                        out.writeInt(list.length);                        out.flush();                                                for (File file : list) {                            out.writeUTF("FILES");                            out.flush();                            out.writeUTF(file.getName());                            out.flush();                            out.writeLong(file.length());                            out.flush();                        }                    }                                        /*REtorna o arquivo solicitado*/                    else if(parse.contains("DOWN ")){                        parse = parse.replace("DOWN ", "");                        parse = parse.replace("\n","").replace("\r", "");                                                System.out.println(pastaPredef+parse);                                                f = new File(pastaPredef);                        list = f.listFiles();                        long tamFile = 0;                        int find = 0;                                                for (File file : list) {                            if(file.getName().equals(parse)){                                outToClient = new FileInputStream(file);                                tamFile = file.length();                                find = 1;                                break;                            }                        }                                                //se achar o arquivo execute                        if(find == 1){                            out.writeUTF("DOWN");                            out.flush();                            out.writeUTF(String.valueOf(tamFile));                            out.flush();                            out.writeUTF(parse);                            out.flush();                            byte[] buffer = new byte[128];                            int count = 0;                            while ((count=outToClient.read(buffer)) > 0) {                                    out.write(buffer, 0, count);                            }                            out.flush();                           }                        //caso não ache o arquivo apenas envie o tamanho como 0                        else{                            out.writeUTF("DOWN");                            out.flush();                            out.writeUTF("0");                            out.flush();                        }                        outToClient.close();                    }                    /*DATE Retorna a data do sistema como uma String UTF no formato DD/MM/AAAA*/                    else if(parse.equals("DATA")){                        Date dateToFormat = new Date();                        SimpleDateFormat dateFormatExpression = new SimpleDateFormat("dd/MM/yyyy"+"\n");                        String formattedDate = dateFormatExpression.format(dateToFormat);                        out.writeUTF(formattedDate);                        out.flush();                    }                                        /*EXIT Finaliza a conexão*/                    else if(parse.equals("EXIT")){                        TCPServer.removeClient(this);                        this.interrupt();                        out.writeUTF("EXIT");                        out.flush();                    }                                        else{                        out.writeUTF(data);                        out.flush();                    }                }                } catch (EOFException e){	    System.out.println("EOF: "+e.getMessage());        } catch(IOException e) {	    System.out.println("leitura: "+e.getMessage());        } //catch	    } //run                } //class